// Code generated by counterfeiter. DO NOT EDIT.
package terraformfakes

import (
	"sync"
	"github.com/ljfranklin/terraform-resource/models"
	"github.com/ljfranklin/terraform-resource/terraform"
)

type FakeClient struct {
	ApplyStub        func() error
	applyMutex       sync.RWMutex
	applyArgsForCall []struct {
	}
	applyReturns struct {
		result1 error
	}
	applyReturnsOnCall map[int]struct {
		result1 error
	}
	CurrentStateVersionStub        func(string) (terraform.StateVersion, error)
	currentStateVersionMutex       sync.RWMutex
	currentStateVersionArgsForCall []struct {
		arg1 string
	}
	currentStateVersionReturns struct {
		result1 terraform.StateVersion
		result2 error
	}
	currentStateVersionReturnsOnCall map[int]struct {
		result1 terraform.StateVersion
		result2 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct {
	}
	destroyReturns struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	GetPlanFromBackendStub        func(string) error
	getPlanFromBackendMutex       sync.RWMutex
	getPlanFromBackendArgsForCall []struct {
		arg1 string
	}
	getPlanFromBackendReturns struct {
		result1 error
	}
	getPlanFromBackendReturnsOnCall map[int]struct {
		result1 error
	}
	ImportStub        func(string) error
	importMutex       sync.RWMutex
	importArgsForCall []struct {
		arg1 string
	}
	importReturns struct {
		result1 error
	}
	importReturnsOnCall map[int]struct {
		result1 error
	}
	ImportWithLegacyStorageStub        func() error
	importWithLegacyStorageMutex       sync.RWMutex
	importWithLegacyStorageArgsForCall []struct {
	}
	importWithLegacyStorageReturns struct {
		result1 error
	}
	importWithLegacyStorageReturnsOnCall map[int]struct {
		result1 error
	}
	InitWithBackendStub        func() error
	initWithBackendMutex       sync.RWMutex
	initWithBackendArgsForCall []struct {
	}
	initWithBackendReturns struct {
		result1 error
	}
	initWithBackendReturnsOnCall map[int]struct {
		result1 error
	}
	InitWithoutBackendStub        func() error
	initWithoutBackendMutex       sync.RWMutex
	initWithoutBackendArgsForCall []struct {
	}
	initWithoutBackendReturns struct {
		result1 error
	}
	initWithoutBackendReturnsOnCall map[int]struct {
		result1 error
	}
	JSONPlanStub        func() error
	jSONPlanMutex       sync.RWMutex
	jSONPlanArgsForCall []struct {
	}
	jSONPlanReturns struct {
		result1 error
	}
	jSONPlanReturnsOnCall map[int]struct {
		result1 error
	}
	OutputStub        func(string) (map[string]map[string]interface{}, error)
	outputMutex       sync.RWMutex
	outputArgsForCall []struct {
		arg1 string
	}
	outputReturns struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	outputReturnsOnCall map[int]struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	OutputWithLegacyStorageStub        func() (map[string]map[string]interface{}, error)
	outputWithLegacyStorageMutex       sync.RWMutex
	outputWithLegacyStorageArgsForCall []struct {
	}
	outputWithLegacyStorageReturns struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	outputWithLegacyStorageReturnsOnCall map[int]struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	PlanStub        func() (string, error)
	planMutex       sync.RWMutex
	planArgsForCall []struct {
	}
	planReturns struct {
		result1 string
		result2 error
	}
	planReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SavePlanToBackendStub        func(string) error
	savePlanToBackendMutex       sync.RWMutex
	savePlanToBackendArgsForCall []struct {
		arg1 string
	}
	savePlanToBackendReturns struct {
		result1 error
	}
	savePlanToBackendReturnsOnCall map[int]struct {
		result1 error
	}
	SetModelStub        func(models.Terraform)
	setModelMutex       sync.RWMutex
	setModelArgsForCall []struct {
		arg1 models.Terraform
	}
	StatePullStub        func(string) ([]byte, error)
	statePullMutex       sync.RWMutex
	statePullArgsForCall []struct {
		arg1 string
	}
	statePullReturns struct {
		result1 []byte
		result2 error
	}
	statePullReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	VersionStub        func() (string, error)
	versionMutex       sync.RWMutex
	versionArgsForCall []struct {
	}
	versionReturns struct {
		result1 string
		result2 error
	}
	versionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	WorkspaceDeleteStub        func(string) error
	workspaceDeleteMutex       sync.RWMutex
	workspaceDeleteArgsForCall []struct {
		arg1 string
	}
	workspaceDeleteReturns struct {
		result1 error
	}
	workspaceDeleteReturnsOnCall map[int]struct {
		result1 error
	}
	WorkspaceDeleteWithForceStub        func(string) error
	workspaceDeleteWithForceMutex       sync.RWMutex
	workspaceDeleteWithForceArgsForCall []struct {
		arg1 string
	}
	workspaceDeleteWithForceReturns struct {
		result1 error
	}
	workspaceDeleteWithForceReturnsOnCall map[int]struct {
		result1 error
	}
	WorkspaceListStub        func() ([]string, error)
	workspaceListMutex       sync.RWMutex
	workspaceListArgsForCall []struct {
	}
	workspaceListReturns struct {
		result1 []string
		result2 error
	}
	workspaceListReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	WorkspaceNewFromExistingStateFileStub        func(string, string) error
	workspaceNewFromExistingStateFileMutex       sync.RWMutex
	workspaceNewFromExistingStateFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	workspaceNewFromExistingStateFileReturns struct {
		result1 error
	}
	workspaceNewFromExistingStateFileReturnsOnCall map[int]struct {
		result1 error
	}
	WorkspaceNewIfNotExistsStub        func(string) error
	workspaceNewIfNotExistsMutex       sync.RWMutex
	workspaceNewIfNotExistsArgsForCall []struct {
		arg1 string
	}
	workspaceNewIfNotExistsReturns struct {
		result1 error
	}
	workspaceNewIfNotExistsReturnsOnCall map[int]struct {
		result1 error
	}
	WorkspaceSelectStub        func(string) error
	workspaceSelectMutex       sync.RWMutex
	workspaceSelectArgsForCall []struct {
		arg1 string
	}
	workspaceSelectReturns struct {
		result1 error
	}
	workspaceSelectReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Apply() error {
	fake.applyMutex.Lock()
	ret, specificReturn := fake.applyReturnsOnCall[len(fake.applyArgsForCall)]
	fake.applyArgsForCall = append(fake.applyArgsForCall, struct {
	}{})
	fake.recordInvocation("Apply", []interface{}{})
	fake.applyMutex.Unlock()
	if fake.ApplyStub != nil {
		return fake.ApplyStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.applyReturns
	return fakeReturns.result1
}

func (fake *FakeClient) ApplyCallCount() int {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	return len(fake.applyArgsForCall)
}

func (fake *FakeClient) ApplyCalls(stub func() error) {
	fake.applyMutex.Lock()
	defer fake.applyMutex.Unlock()
	fake.ApplyStub = stub
}

func (fake *FakeClient) ApplyReturns(result1 error) {
	fake.applyMutex.Lock()
	defer fake.applyMutex.Unlock()
	fake.ApplyStub = nil
	fake.applyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ApplyReturnsOnCall(i int, result1 error) {
	fake.applyMutex.Lock()
	defer fake.applyMutex.Unlock()
	fake.ApplyStub = nil
	if fake.applyReturnsOnCall == nil {
		fake.applyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.applyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CurrentStateVersion(arg1 string) (terraform.StateVersion, error) {
	fake.currentStateVersionMutex.Lock()
	ret, specificReturn := fake.currentStateVersionReturnsOnCall[len(fake.currentStateVersionArgsForCall)]
	fake.currentStateVersionArgsForCall = append(fake.currentStateVersionArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CurrentStateVersion", []interface{}{arg1})
	fake.currentStateVersionMutex.Unlock()
	if fake.CurrentStateVersionStub != nil {
		return fake.CurrentStateVersionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentStateVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CurrentStateVersionCallCount() int {
	fake.currentStateVersionMutex.RLock()
	defer fake.currentStateVersionMutex.RUnlock()
	return len(fake.currentStateVersionArgsForCall)
}

func (fake *FakeClient) CurrentStateVersionCalls(stub func(string) (terraform.StateVersion, error)) {
	fake.currentStateVersionMutex.Lock()
	defer fake.currentStateVersionMutex.Unlock()
	fake.CurrentStateVersionStub = stub
}

func (fake *FakeClient) CurrentStateVersionArgsForCall(i int) string {
	fake.currentStateVersionMutex.RLock()
	defer fake.currentStateVersionMutex.RUnlock()
	argsForCall := fake.currentStateVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CurrentStateVersionReturns(result1 terraform.StateVersion, result2 error) {
	fake.currentStateVersionMutex.Lock()
	defer fake.currentStateVersionMutex.Unlock()
	fake.CurrentStateVersionStub = nil
	fake.currentStateVersionReturns = struct {
		result1 terraform.StateVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CurrentStateVersionReturnsOnCall(i int, result1 terraform.StateVersion, result2 error) {
	fake.currentStateVersionMutex.Lock()
	defer fake.currentStateVersionMutex.Unlock()
	fake.CurrentStateVersionStub = nil
	if fake.currentStateVersionReturnsOnCall == nil {
		fake.currentStateVersionReturnsOnCall = make(map[int]struct {
			result1 terraform.StateVersion
			result2 error
		})
	}
	fake.currentStateVersionReturnsOnCall[i] = struct {
		result1 terraform.StateVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Destroy() error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct {
	}{})
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.destroyReturns
	return fakeReturns.result1
}

func (fake *FakeClient) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakeClient) DestroyCalls(stub func() error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = stub
}

func (fake *FakeClient) DestroyReturns(result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DestroyReturnsOnCall(i int, result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetPlanFromBackend(arg1 string) error {
	fake.getPlanFromBackendMutex.Lock()
	ret, specificReturn := fake.getPlanFromBackendReturnsOnCall[len(fake.getPlanFromBackendArgsForCall)]
	fake.getPlanFromBackendArgsForCall = append(fake.getPlanFromBackendArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetPlanFromBackend", []interface{}{arg1})
	fake.getPlanFromBackendMutex.Unlock()
	if fake.GetPlanFromBackendStub != nil {
		return fake.GetPlanFromBackendStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getPlanFromBackendReturns
	return fakeReturns.result1
}

func (fake *FakeClient) GetPlanFromBackendCallCount() int {
	fake.getPlanFromBackendMutex.RLock()
	defer fake.getPlanFromBackendMutex.RUnlock()
	return len(fake.getPlanFromBackendArgsForCall)
}

func (fake *FakeClient) GetPlanFromBackendCalls(stub func(string) error) {
	fake.getPlanFromBackendMutex.Lock()
	defer fake.getPlanFromBackendMutex.Unlock()
	fake.GetPlanFromBackendStub = stub
}

func (fake *FakeClient) GetPlanFromBackendArgsForCall(i int) string {
	fake.getPlanFromBackendMutex.RLock()
	defer fake.getPlanFromBackendMutex.RUnlock()
	argsForCall := fake.getPlanFromBackendArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetPlanFromBackendReturns(result1 error) {
	fake.getPlanFromBackendMutex.Lock()
	defer fake.getPlanFromBackendMutex.Unlock()
	fake.GetPlanFromBackendStub = nil
	fake.getPlanFromBackendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetPlanFromBackendReturnsOnCall(i int, result1 error) {
	fake.getPlanFromBackendMutex.Lock()
	defer fake.getPlanFromBackendMutex.Unlock()
	fake.GetPlanFromBackendStub = nil
	if fake.getPlanFromBackendReturnsOnCall == nil {
		fake.getPlanFromBackendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getPlanFromBackendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Import(arg1 string) error {
	fake.importMutex.Lock()
	ret, specificReturn := fake.importReturnsOnCall[len(fake.importArgsForCall)]
	fake.importArgsForCall = append(fake.importArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Import", []interface{}{arg1})
	fake.importMutex.Unlock()
	if fake.ImportStub != nil {
		return fake.ImportStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.importReturns
	return fakeReturns.result1
}

func (fake *FakeClient) ImportCallCount() int {
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	return len(fake.importArgsForCall)
}

func (fake *FakeClient) ImportCalls(stub func(string) error) {
	fake.importMutex.Lock()
	defer fake.importMutex.Unlock()
	fake.ImportStub = stub
}

func (fake *FakeClient) ImportArgsForCall(i int) string {
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	argsForCall := fake.importArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ImportReturns(result1 error) {
	fake.importMutex.Lock()
	defer fake.importMutex.Unlock()
	fake.ImportStub = nil
	fake.importReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ImportReturnsOnCall(i int, result1 error) {
	fake.importMutex.Lock()
	defer fake.importMutex.Unlock()
	fake.ImportStub = nil
	if fake.importReturnsOnCall == nil {
		fake.importReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.importReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ImportWithLegacyStorage() error {
	fake.importWithLegacyStorageMutex.Lock()
	ret, specificReturn := fake.importWithLegacyStorageReturnsOnCall[len(fake.importWithLegacyStorageArgsForCall)]
	fake.importWithLegacyStorageArgsForCall = append(fake.importWithLegacyStorageArgsForCall, struct {
	}{})
	fake.recordInvocation("ImportWithLegacyStorage", []interface{}{})
	fake.importWithLegacyStorageMutex.Unlock()
	if fake.ImportWithLegacyStorageStub != nil {
		return fake.ImportWithLegacyStorageStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.importWithLegacyStorageReturns
	return fakeReturns.result1
}

func (fake *FakeClient) ImportWithLegacyStorageCallCount() int {
	fake.importWithLegacyStorageMutex.RLock()
	defer fake.importWithLegacyStorageMutex.RUnlock()
	return len(fake.importWithLegacyStorageArgsForCall)
}

func (fake *FakeClient) ImportWithLegacyStorageCalls(stub func() error) {
	fake.importWithLegacyStorageMutex.Lock()
	defer fake.importWithLegacyStorageMutex.Unlock()
	fake.ImportWithLegacyStorageStub = stub
}

func (fake *FakeClient) ImportWithLegacyStorageReturns(result1 error) {
	fake.importWithLegacyStorageMutex.Lock()
	defer fake.importWithLegacyStorageMutex.Unlock()
	fake.ImportWithLegacyStorageStub = nil
	fake.importWithLegacyStorageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ImportWithLegacyStorageReturnsOnCall(i int, result1 error) {
	fake.importWithLegacyStorageMutex.Lock()
	defer fake.importWithLegacyStorageMutex.Unlock()
	fake.ImportWithLegacyStorageStub = nil
	if fake.importWithLegacyStorageReturnsOnCall == nil {
		fake.importWithLegacyStorageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.importWithLegacyStorageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithBackend() error {
	fake.initWithBackendMutex.Lock()
	ret, specificReturn := fake.initWithBackendReturnsOnCall[len(fake.initWithBackendArgsForCall)]
	fake.initWithBackendArgsForCall = append(fake.initWithBackendArgsForCall, struct {
	}{})
	fake.recordInvocation("InitWithBackend", []interface{}{})
	fake.initWithBackendMutex.Unlock()
	if fake.InitWithBackendStub != nil {
		return fake.InitWithBackendStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.initWithBackendReturns
	return fakeReturns.result1
}

func (fake *FakeClient) InitWithBackendCallCount() int {
	fake.initWithBackendMutex.RLock()
	defer fake.initWithBackendMutex.RUnlock()
	return len(fake.initWithBackendArgsForCall)
}

func (fake *FakeClient) InitWithBackendCalls(stub func() error) {
	fake.initWithBackendMutex.Lock()
	defer fake.initWithBackendMutex.Unlock()
	fake.InitWithBackendStub = stub
}

func (fake *FakeClient) InitWithBackendReturns(result1 error) {
	fake.initWithBackendMutex.Lock()
	defer fake.initWithBackendMutex.Unlock()
	fake.InitWithBackendStub = nil
	fake.initWithBackendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithBackendReturnsOnCall(i int, result1 error) {
	fake.initWithBackendMutex.Lock()
	defer fake.initWithBackendMutex.Unlock()
	fake.InitWithBackendStub = nil
	if fake.initWithBackendReturnsOnCall == nil {
		fake.initWithBackendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initWithBackendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithoutBackend() error {
	fake.initWithoutBackendMutex.Lock()
	ret, specificReturn := fake.initWithoutBackendReturnsOnCall[len(fake.initWithoutBackendArgsForCall)]
	fake.initWithoutBackendArgsForCall = append(fake.initWithoutBackendArgsForCall, struct {
	}{})
	fake.recordInvocation("InitWithoutBackend", []interface{}{})
	fake.initWithoutBackendMutex.Unlock()
	if fake.InitWithoutBackendStub != nil {
		return fake.InitWithoutBackendStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.initWithoutBackendReturns
	return fakeReturns.result1
}

func (fake *FakeClient) InitWithoutBackendCallCount() int {
	fake.initWithoutBackendMutex.RLock()
	defer fake.initWithoutBackendMutex.RUnlock()
	return len(fake.initWithoutBackendArgsForCall)
}

func (fake *FakeClient) InitWithoutBackendCalls(stub func() error) {
	fake.initWithoutBackendMutex.Lock()
	defer fake.initWithoutBackendMutex.Unlock()
	fake.InitWithoutBackendStub = stub
}

func (fake *FakeClient) InitWithoutBackendReturns(result1 error) {
	fake.initWithoutBackendMutex.Lock()
	defer fake.initWithoutBackendMutex.Unlock()
	fake.InitWithoutBackendStub = nil
	fake.initWithoutBackendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithoutBackendReturnsOnCall(i int, result1 error) {
	fake.initWithoutBackendMutex.Lock()
	defer fake.initWithoutBackendMutex.Unlock()
	fake.InitWithoutBackendStub = nil
	if fake.initWithoutBackendReturnsOnCall == nil {
		fake.initWithoutBackendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initWithoutBackendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) JSONPlan() error {
	fake.jSONPlanMutex.Lock()
	ret, specificReturn := fake.jSONPlanReturnsOnCall[len(fake.jSONPlanArgsForCall)]
	fake.jSONPlanArgsForCall = append(fake.jSONPlanArgsForCall, struct {
	}{})
	fake.recordInvocation("JSONPlan", []interface{}{})
	fake.jSONPlanMutex.Unlock()
	if fake.JSONPlanStub != nil {
		return fake.JSONPlanStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.jSONPlanReturns
	return fakeReturns.result1
}

func (fake *FakeClient) JSONPlanCallCount() int {
	fake.jSONPlanMutex.RLock()
	defer fake.jSONPlanMutex.RUnlock()
	return len(fake.jSONPlanArgsForCall)
}

func (fake *FakeClient) JSONPlanCalls(stub func() error) {
	fake.jSONPlanMutex.Lock()
	defer fake.jSONPlanMutex.Unlock()
	fake.JSONPlanStub = stub
}

func (fake *FakeClient) JSONPlanReturns(result1 error) {
	fake.jSONPlanMutex.Lock()
	defer fake.jSONPlanMutex.Unlock()
	fake.JSONPlanStub = nil
	fake.jSONPlanReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) JSONPlanReturnsOnCall(i int, result1 error) {
	fake.jSONPlanMutex.Lock()
	defer fake.jSONPlanMutex.Unlock()
	fake.JSONPlanStub = nil
	if fake.jSONPlanReturnsOnCall == nil {
		fake.jSONPlanReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.jSONPlanReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Output(arg1 string) (map[string]map[string]interface{}, error) {
	fake.outputMutex.Lock()
	ret, specificReturn := fake.outputReturnsOnCall[len(fake.outputArgsForCall)]
	fake.outputArgsForCall = append(fake.outputArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Output", []interface{}{arg1})
	fake.outputMutex.Unlock()
	if fake.OutputStub != nil {
		return fake.OutputStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.outputReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) OutputCallCount() int {
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	return len(fake.outputArgsForCall)
}

func (fake *FakeClient) OutputCalls(stub func(string) (map[string]map[string]interface{}, error)) {
	fake.outputMutex.Lock()
	defer fake.outputMutex.Unlock()
	fake.OutputStub = stub
}

func (fake *FakeClient) OutputArgsForCall(i int) string {
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	argsForCall := fake.outputArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) OutputReturns(result1 map[string]map[string]interface{}, result2 error) {
	fake.outputMutex.Lock()
	defer fake.outputMutex.Unlock()
	fake.OutputStub = nil
	fake.outputReturns = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OutputReturnsOnCall(i int, result1 map[string]map[string]interface{}, result2 error) {
	fake.outputMutex.Lock()
	defer fake.outputMutex.Unlock()
	fake.OutputStub = nil
	if fake.outputReturnsOnCall == nil {
		fake.outputReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string]interface{}
			result2 error
		})
	}
	fake.outputReturnsOnCall[i] = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OutputWithLegacyStorage() (map[string]map[string]interface{}, error) {
	fake.outputWithLegacyStorageMutex.Lock()
	ret, specificReturn := fake.outputWithLegacyStorageReturnsOnCall[len(fake.outputWithLegacyStorageArgsForCall)]
	fake.outputWithLegacyStorageArgsForCall = append(fake.outputWithLegacyStorageArgsForCall, struct {
	}{})
	fake.recordInvocation("OutputWithLegacyStorage", []interface{}{})
	fake.outputWithLegacyStorageMutex.Unlock()
	if fake.OutputWithLegacyStorageStub != nil {
		return fake.OutputWithLegacyStorageStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.outputWithLegacyStorageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) OutputWithLegacyStorageCallCount() int {
	fake.outputWithLegacyStorageMutex.RLock()
	defer fake.outputWithLegacyStorageMutex.RUnlock()
	return len(fake.outputWithLegacyStorageArgsForCall)
}

func (fake *FakeClient) OutputWithLegacyStorageCalls(stub func() (map[string]map[string]interface{}, error)) {
	fake.outputWithLegacyStorageMutex.Lock()
	defer fake.outputWithLegacyStorageMutex.Unlock()
	fake.OutputWithLegacyStorageStub = stub
}

func (fake *FakeClient) OutputWithLegacyStorageReturns(result1 map[string]map[string]interface{}, result2 error) {
	fake.outputWithLegacyStorageMutex.Lock()
	defer fake.outputWithLegacyStorageMutex.Unlock()
	fake.OutputWithLegacyStorageStub = nil
	fake.outputWithLegacyStorageReturns = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OutputWithLegacyStorageReturnsOnCall(i int, result1 map[string]map[string]interface{}, result2 error) {
	fake.outputWithLegacyStorageMutex.Lock()
	defer fake.outputWithLegacyStorageMutex.Unlock()
	fake.OutputWithLegacyStorageStub = nil
	if fake.outputWithLegacyStorageReturnsOnCall == nil {
		fake.outputWithLegacyStorageReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string]interface{}
			result2 error
		})
	}
	fake.outputWithLegacyStorageReturnsOnCall[i] = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Plan() (string, error) {
	fake.planMutex.Lock()
	ret, specificReturn := fake.planReturnsOnCall[len(fake.planArgsForCall)]
	fake.planArgsForCall = append(fake.planArgsForCall, struct {
	}{})
	fake.recordInvocation("Plan", []interface{}{})
	fake.planMutex.Unlock()
	if fake.PlanStub != nil {
		return fake.PlanStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.planReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PlanCallCount() int {
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	return len(fake.planArgsForCall)
}

func (fake *FakeClient) PlanCalls(stub func() (string, error)) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = stub
}

func (fake *FakeClient) PlanReturns(result1 string, result2 error) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = nil
	fake.planReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PlanReturnsOnCall(i int, result1 string, result2 error) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = nil
	if fake.planReturnsOnCall == nil {
		fake.planReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.planReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SavePlanToBackend(arg1 string) error {
	fake.savePlanToBackendMutex.Lock()
	ret, specificReturn := fake.savePlanToBackendReturnsOnCall[len(fake.savePlanToBackendArgsForCall)]
	fake.savePlanToBackendArgsForCall = append(fake.savePlanToBackendArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SavePlanToBackend", []interface{}{arg1})
	fake.savePlanToBackendMutex.Unlock()
	if fake.SavePlanToBackendStub != nil {
		return fake.SavePlanToBackendStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.savePlanToBackendReturns
	return fakeReturns.result1
}

func (fake *FakeClient) SavePlanToBackendCallCount() int {
	fake.savePlanToBackendMutex.RLock()
	defer fake.savePlanToBackendMutex.RUnlock()
	return len(fake.savePlanToBackendArgsForCall)
}

func (fake *FakeClient) SavePlanToBackendCalls(stub func(string) error) {
	fake.savePlanToBackendMutex.Lock()
	defer fake.savePlanToBackendMutex.Unlock()
	fake.SavePlanToBackendStub = stub
}

func (fake *FakeClient) SavePlanToBackendArgsForCall(i int) string {
	fake.savePlanToBackendMutex.RLock()
	defer fake.savePlanToBackendMutex.RUnlock()
	argsForCall := fake.savePlanToBackendArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SavePlanToBackendReturns(result1 error) {
	fake.savePlanToBackendMutex.Lock()
	defer fake.savePlanToBackendMutex.Unlock()
	fake.SavePlanToBackendStub = nil
	fake.savePlanToBackendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) SavePlanToBackendReturnsOnCall(i int, result1 error) {
	fake.savePlanToBackendMutex.Lock()
	defer fake.savePlanToBackendMutex.Unlock()
	fake.SavePlanToBackendStub = nil
	if fake.savePlanToBackendReturnsOnCall == nil {
		fake.savePlanToBackendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.savePlanToBackendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) SetModel(arg1 models.Terraform) {
	fake.setModelMutex.Lock()
	fake.setModelArgsForCall = append(fake.setModelArgsForCall, struct {
		arg1 models.Terraform
	}{arg1})
	fake.recordInvocation("SetModel", []interface{}{arg1})
	fake.setModelMutex.Unlock()
	if fake.SetModelStub != nil {
		fake.SetModelStub(arg1)
	}
}

func (fake *FakeClient) SetModelCallCount() int {
	fake.setModelMutex.RLock()
	defer fake.setModelMutex.RUnlock()
	return len(fake.setModelArgsForCall)
}

func (fake *FakeClient) SetModelCalls(stub func(models.Terraform)) {
	fake.setModelMutex.Lock()
	defer fake.setModelMutex.Unlock()
	fake.SetModelStub = stub
}

func (fake *FakeClient) SetModelArgsForCall(i int) models.Terraform {
	fake.setModelMutex.RLock()
	defer fake.setModelMutex.RUnlock()
	argsForCall := fake.setModelArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) StatePull(arg1 string) ([]byte, error) {
	fake.statePullMutex.Lock()
	ret, specificReturn := fake.statePullReturnsOnCall[len(fake.statePullArgsForCall)]
	fake.statePullArgsForCall = append(fake.statePullArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("StatePull", []interface{}{arg1})
	fake.statePullMutex.Unlock()
	if fake.StatePullStub != nil {
		return fake.StatePullStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.statePullReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) StatePullCallCount() int {
	fake.statePullMutex.RLock()
	defer fake.statePullMutex.RUnlock()
	return len(fake.statePullArgsForCall)
}

func (fake *FakeClient) StatePullCalls(stub func(string) ([]byte, error)) {
	fake.statePullMutex.Lock()
	defer fake.statePullMutex.Unlock()
	fake.StatePullStub = stub
}

func (fake *FakeClient) StatePullArgsForCall(i int) string {
	fake.statePullMutex.RLock()
	defer fake.statePullMutex.RUnlock()
	argsForCall := fake.statePullArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) StatePullReturns(result1 []byte, result2 error) {
	fake.statePullMutex.Lock()
	defer fake.statePullMutex.Unlock()
	fake.StatePullStub = nil
	fake.statePullReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) StatePullReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.statePullMutex.Lock()
	defer fake.statePullMutex.Unlock()
	fake.StatePullStub = nil
	if fake.statePullReturnsOnCall == nil {
		fake.statePullReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.statePullReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Version() (string, error) {
	fake.versionMutex.Lock()
	ret, specificReturn := fake.versionReturnsOnCall[len(fake.versionArgsForCall)]
	fake.versionArgsForCall = append(fake.versionArgsForCall, struct {
	}{})
	fake.recordInvocation("Version", []interface{}{})
	fake.versionMutex.Unlock()
	if fake.VersionStub != nil {
		return fake.VersionStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.versionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) VersionCallCount() int {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return len(fake.versionArgsForCall)
}

func (fake *FakeClient) VersionCalls(stub func() (string, error)) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = stub
}

func (fake *FakeClient) VersionReturns(result1 string, result2 error) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	fake.versionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) VersionReturnsOnCall(i int, result1 string, result2 error) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	if fake.versionReturnsOnCall == nil {
		fake.versionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.versionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WorkspaceDelete(arg1 string) error {
	fake.workspaceDeleteMutex.Lock()
	ret, specificReturn := fake.workspaceDeleteReturnsOnCall[len(fake.workspaceDeleteArgsForCall)]
	fake.workspaceDeleteArgsForCall = append(fake.workspaceDeleteArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WorkspaceDelete", []interface{}{arg1})
	fake.workspaceDeleteMutex.Unlock()
	if fake.WorkspaceDeleteStub != nil {
		return fake.WorkspaceDeleteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.workspaceDeleteReturns
	return fakeReturns.result1
}

func (fake *FakeClient) WorkspaceDeleteCallCount() int {
	fake.workspaceDeleteMutex.RLock()
	defer fake.workspaceDeleteMutex.RUnlock()
	return len(fake.workspaceDeleteArgsForCall)
}

func (fake *FakeClient) WorkspaceDeleteCalls(stub func(string) error) {
	fake.workspaceDeleteMutex.Lock()
	defer fake.workspaceDeleteMutex.Unlock()
	fake.WorkspaceDeleteStub = stub
}

func (fake *FakeClient) WorkspaceDeleteArgsForCall(i int) string {
	fake.workspaceDeleteMutex.RLock()
	defer fake.workspaceDeleteMutex.RUnlock()
	argsForCall := fake.workspaceDeleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) WorkspaceDeleteReturns(result1 error) {
	fake.workspaceDeleteMutex.Lock()
	defer fake.workspaceDeleteMutex.Unlock()
	fake.WorkspaceDeleteStub = nil
	fake.workspaceDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceDeleteReturnsOnCall(i int, result1 error) {
	fake.workspaceDeleteMutex.Lock()
	defer fake.workspaceDeleteMutex.Unlock()
	fake.WorkspaceDeleteStub = nil
	if fake.workspaceDeleteReturnsOnCall == nil {
		fake.workspaceDeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceDeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceDeleteWithForce(arg1 string) error {
	fake.workspaceDeleteWithForceMutex.Lock()
	ret, specificReturn := fake.workspaceDeleteWithForceReturnsOnCall[len(fake.workspaceDeleteWithForceArgsForCall)]
	fake.workspaceDeleteWithForceArgsForCall = append(fake.workspaceDeleteWithForceArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WorkspaceDeleteWithForce", []interface{}{arg1})
	fake.workspaceDeleteWithForceMutex.Unlock()
	if fake.WorkspaceDeleteWithForceStub != nil {
		return fake.WorkspaceDeleteWithForceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.workspaceDeleteWithForceReturns
	return fakeReturns.result1
}

func (fake *FakeClient) WorkspaceDeleteWithForceCallCount() int {
	fake.workspaceDeleteWithForceMutex.RLock()
	defer fake.workspaceDeleteWithForceMutex.RUnlock()
	return len(fake.workspaceDeleteWithForceArgsForCall)
}

func (fake *FakeClient) WorkspaceDeleteWithForceCalls(stub func(string) error) {
	fake.workspaceDeleteWithForceMutex.Lock()
	defer fake.workspaceDeleteWithForceMutex.Unlock()
	fake.WorkspaceDeleteWithForceStub = stub
}

func (fake *FakeClient) WorkspaceDeleteWithForceArgsForCall(i int) string {
	fake.workspaceDeleteWithForceMutex.RLock()
	defer fake.workspaceDeleteWithForceMutex.RUnlock()
	argsForCall := fake.workspaceDeleteWithForceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) WorkspaceDeleteWithForceReturns(result1 error) {
	fake.workspaceDeleteWithForceMutex.Lock()
	defer fake.workspaceDeleteWithForceMutex.Unlock()
	fake.WorkspaceDeleteWithForceStub = nil
	fake.workspaceDeleteWithForceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceDeleteWithForceReturnsOnCall(i int, result1 error) {
	fake.workspaceDeleteWithForceMutex.Lock()
	defer fake.workspaceDeleteWithForceMutex.Unlock()
	fake.WorkspaceDeleteWithForceStub = nil
	if fake.workspaceDeleteWithForceReturnsOnCall == nil {
		fake.workspaceDeleteWithForceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceDeleteWithForceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceList() ([]string, error) {
	fake.workspaceListMutex.Lock()
	ret, specificReturn := fake.workspaceListReturnsOnCall[len(fake.workspaceListArgsForCall)]
	fake.workspaceListArgsForCall = append(fake.workspaceListArgsForCall, struct {
	}{})
	fake.recordInvocation("WorkspaceList", []interface{}{})
	fake.workspaceListMutex.Unlock()
	if fake.WorkspaceListStub != nil {
		return fake.WorkspaceListStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.workspaceListReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) WorkspaceListCallCount() int {
	fake.workspaceListMutex.RLock()
	defer fake.workspaceListMutex.RUnlock()
	return len(fake.workspaceListArgsForCall)
}

func (fake *FakeClient) WorkspaceListCalls(stub func() ([]string, error)) {
	fake.workspaceListMutex.Lock()
	defer fake.workspaceListMutex.Unlock()
	fake.WorkspaceListStub = stub
}

func (fake *FakeClient) WorkspaceListReturns(result1 []string, result2 error) {
	fake.workspaceListMutex.Lock()
	defer fake.workspaceListMutex.Unlock()
	fake.WorkspaceListStub = nil
	fake.workspaceListReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WorkspaceListReturnsOnCall(i int, result1 []string, result2 error) {
	fake.workspaceListMutex.Lock()
	defer fake.workspaceListMutex.Unlock()
	fake.WorkspaceListStub = nil
	if fake.workspaceListReturnsOnCall == nil {
		fake.workspaceListReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.workspaceListReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFile(arg1 string, arg2 string) error {
	fake.workspaceNewFromExistingStateFileMutex.Lock()
	ret, specificReturn := fake.workspaceNewFromExistingStateFileReturnsOnCall[len(fake.workspaceNewFromExistingStateFileArgsForCall)]
	fake.workspaceNewFromExistingStateFileArgsForCall = append(fake.workspaceNewFromExistingStateFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("WorkspaceNewFromExistingStateFile", []interface{}{arg1, arg2})
	fake.workspaceNewFromExistingStateFileMutex.Unlock()
	if fake.WorkspaceNewFromExistingStateFileStub != nil {
		return fake.WorkspaceNewFromExistingStateFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.workspaceNewFromExistingStateFileReturns
	return fakeReturns.result1
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileCallCount() int {
	fake.workspaceNewFromExistingStateFileMutex.RLock()
	defer fake.workspaceNewFromExistingStateFileMutex.RUnlock()
	return len(fake.workspaceNewFromExistingStateFileArgsForCall)
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileCalls(stub func(string, string) error) {
	fake.workspaceNewFromExistingStateFileMutex.Lock()
	defer fake.workspaceNewFromExistingStateFileMutex.Unlock()
	fake.WorkspaceNewFromExistingStateFileStub = stub
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileArgsForCall(i int) (string, string) {
	fake.workspaceNewFromExistingStateFileMutex.RLock()
	defer fake.workspaceNewFromExistingStateFileMutex.RUnlock()
	argsForCall := fake.workspaceNewFromExistingStateFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileReturns(result1 error) {
	fake.workspaceNewFromExistingStateFileMutex.Lock()
	defer fake.workspaceNewFromExistingStateFileMutex.Unlock()
	fake.WorkspaceNewFromExistingStateFileStub = nil
	fake.workspaceNewFromExistingStateFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileReturnsOnCall(i int, result1 error) {
	fake.workspaceNewFromExistingStateFileMutex.Lock()
	defer fake.workspaceNewFromExistingStateFileMutex.Unlock()
	fake.WorkspaceNewFromExistingStateFileStub = nil
	if fake.workspaceNewFromExistingStateFileReturnsOnCall == nil {
		fake.workspaceNewFromExistingStateFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceNewFromExistingStateFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceNewIfNotExists(arg1 string) error {
	fake.workspaceNewIfNotExistsMutex.Lock()
	ret, specificReturn := fake.workspaceNewIfNotExistsReturnsOnCall[len(fake.workspaceNewIfNotExistsArgsForCall)]
	fake.workspaceNewIfNotExistsArgsForCall = append(fake.workspaceNewIfNotExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WorkspaceNewIfNotExists", []interface{}{arg1})
	fake.workspaceNewIfNotExistsMutex.Unlock()
	if fake.WorkspaceNewIfNotExistsStub != nil {
		return fake.WorkspaceNewIfNotExistsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.workspaceNewIfNotExistsReturns
	return fakeReturns.result1
}

func (fake *FakeClient) WorkspaceNewIfNotExistsCallCount() int {
	fake.workspaceNewIfNotExistsMutex.RLock()
	defer fake.workspaceNewIfNotExistsMutex.RUnlock()
	return len(fake.workspaceNewIfNotExistsArgsForCall)
}

func (fake *FakeClient) WorkspaceNewIfNotExistsCalls(stub func(string) error) {
	fake.workspaceNewIfNotExistsMutex.Lock()
	defer fake.workspaceNewIfNotExistsMutex.Unlock()
	fake.WorkspaceNewIfNotExistsStub = stub
}

func (fake *FakeClient) WorkspaceNewIfNotExistsArgsForCall(i int) string {
	fake.workspaceNewIfNotExistsMutex.RLock()
	defer fake.workspaceNewIfNotExistsMutex.RUnlock()
	argsForCall := fake.workspaceNewIfNotExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) WorkspaceNewIfNotExistsReturns(result1 error) {
	fake.workspaceNewIfNotExistsMutex.Lock()
	defer fake.workspaceNewIfNotExistsMutex.Unlock()
	fake.WorkspaceNewIfNotExistsStub = nil
	fake.workspaceNewIfNotExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceNewIfNotExistsReturnsOnCall(i int, result1 error) {
	fake.workspaceNewIfNotExistsMutex.Lock()
	defer fake.workspaceNewIfNotExistsMutex.Unlock()
	fake.WorkspaceNewIfNotExistsStub = nil
	if fake.workspaceNewIfNotExistsReturnsOnCall == nil {
		fake.workspaceNewIfNotExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceNewIfNotExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceSelect(arg1 string) error {
	fake.workspaceSelectMutex.Lock()
	ret, specificReturn := fake.workspaceSelectReturnsOnCall[len(fake.workspaceSelectArgsForCall)]
	fake.workspaceSelectArgsForCall = append(fake.workspaceSelectArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WorkspaceSelect", []interface{}{arg1})
	fake.workspaceSelectMutex.Unlock()
	if fake.WorkspaceSelectStub != nil {
		return fake.WorkspaceSelectStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.workspaceSelectReturns
	return fakeReturns.result1
}

func (fake *FakeClient) WorkspaceSelectCallCount() int {
	fake.workspaceSelectMutex.RLock()
	defer fake.workspaceSelectMutex.RUnlock()
	return len(fake.workspaceSelectArgsForCall)
}

func (fake *FakeClient) WorkspaceSelectCalls(stub func(string) error) {
	fake.workspaceSelectMutex.Lock()
	defer fake.workspaceSelectMutex.Unlock()
	fake.WorkspaceSelectStub = stub
}

func (fake *FakeClient) WorkspaceSelectArgsForCall(i int) string {
	fake.workspaceSelectMutex.RLock()
	defer fake.workspaceSelectMutex.RUnlock()
	argsForCall := fake.workspaceSelectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) WorkspaceSelectReturns(result1 error) {
	fake.workspaceSelectMutex.Lock()
	defer fake.workspaceSelectMutex.Unlock()
	fake.WorkspaceSelectStub = nil
	fake.workspaceSelectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceSelectReturnsOnCall(i int, result1 error) {
	fake.workspaceSelectMutex.Lock()
	defer fake.workspaceSelectMutex.Unlock()
	fake.WorkspaceSelectStub = nil
	if fake.workspaceSelectReturnsOnCall == nil {
		fake.workspaceSelectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceSelectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	fake.currentStateVersionMutex.RLock()
	defer fake.currentStateVersionMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.getPlanFromBackendMutex.RLock()
	defer fake.getPlanFromBackendMutex.RUnlock()
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	fake.importWithLegacyStorageMutex.RLock()
	defer fake.importWithLegacyStorageMutex.RUnlock()
	fake.initWithBackendMutex.RLock()
	defer fake.initWithBackendMutex.RUnlock()
	fake.initWithoutBackendMutex.RLock()
	defer fake.initWithoutBackendMutex.RUnlock()
	fake.jSONPlanMutex.RLock()
	defer fake.jSONPlanMutex.RUnlock()
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	fake.outputWithLegacyStorageMutex.RLock()
	defer fake.outputWithLegacyStorageMutex.RUnlock()
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	fake.savePlanToBackendMutex.RLock()
	defer fake.savePlanToBackendMutex.RUnlock()
	fake.setModelMutex.RLock()
	defer fake.setModelMutex.RUnlock()
	fake.statePullMutex.RLock()
	defer fake.statePullMutex.RUnlock()
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	fake.workspaceDeleteMutex.RLock()
	defer fake.workspaceDeleteMutex.RUnlock()
	fake.workspaceDeleteWithForceMutex.RLock()
	defer fake.workspaceDeleteWithForceMutex.RUnlock()
	fake.workspaceListMutex.RLock()
	defer fake.workspaceListMutex.RUnlock()
	fake.workspaceNewFromExistingStateFileMutex.RLock()
	defer fake.workspaceNewFromExistingStateFileMutex.RUnlock()
	fake.workspaceNewIfNotExistsMutex.RLock()
	defer fake.workspaceNewIfNotExistsMutex.RUnlock()
	fake.workspaceSelectMutex.RLock()
	defer fake.workspaceSelectMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ terraform.Client = new(FakeClient)
